**计算系统的基本元素**

### 第6章 汇编器

“名字里有什么？玫瑰换个名字闻起来依旧芬芳。”  
——莎士比亚，《罗密欧与朱丽叶》

书的前五章描述并构建了计算机的硬件平台。后半部分（第6-12章）则聚焦于计算机的软件层次，最终开发出一种简单的、基于对象的编程语言的编译器和基础操作系统。软件层次中的第一个也是最基本的模块是**汇编器（Assembler）**。第四章已经介绍了机器语言的汇编和二进制表示。本章将描述汇编器如何将用前者编写的程序系统地翻译成用后者编写的程序。随着章节的展开，我们将解释如何开发一个Hack汇编器——一个生成二进制代码的程序，该代码可以直接在第五章构建的硬件平台上运行。

由于符号汇编命令与其对应的二进制代码之间的关系相对简单，使用高级语言编写汇编器并不是一项难事。但汇编程序允许使用符号引用内存地址，带来了一个小小的复杂性。汇编器需要管理这些用户定义的符号，并将它们解析为物理内存地址。通常，这个任务是通过**符号表（symbol table）**来完成的——这是一个在许多软件翻译项目中都要用到的经典数据结构。

正如惯例，Hack汇编器本身不是最终目的。它只是对构建任何汇编器时所使用的关键软件工程原理的简明演示。此外，编写汇编器是后续软件开发项目中的第一个。不同于硬件项目，这些翻译器（包括汇编器、虚拟机、编译器）可以使用任何编程语言来实现。在每个项目中，我们提供了与语言无关的API和详细的逐步测试计划，以及所有必要的测试程序和测试脚本。每个项目，包括汇编器，都是一个独立的模块，可以与其他项目分开开发和测试。

### 6.1 背景

机器语言通常以符号和二进制两种形式指定。二进制代码（如`110000101000000110000000000000111`）表示实际的机器指令，由底层硬件理解。例如，指令的最左边8位可能代表操作码（如LOAD），接下来的8位表示寄存器（如R3），剩下的16位表示地址（如7）。根据硬件的逻辑设计和商定的机器语言，这个32位的模式可能会使硬件执行“将Memory[7]的内容加载到寄存器R3中”的操作。现代计算机平台支持数十甚至数百种此类基本操作，因此机器语言可能非常复杂，涉及许多操作码、不同的内存寻址模式和多种指令格式。

应对这种复杂性的一个方法是使用商定的语法记录机器指令，比如`LOAD R3,7`而不是`110000101000000110000000000000111`。由于从符号表示到二进制代码的转换相对简单，因此可以允许低级程序使用符号表示编写，并通过计算机程序将其翻译成二进制代码。这种符号语言称为**汇编语言（assembly）**，翻译程序称为**汇编器（assembler）**。汇编器将每个汇编命令解析成其底层字段，将每个字段翻译成对应的二进制代码，并将生成的代码组合成硬件可实际执行的二进制指令。

在二进制代码中，指令使用实际的数字来引用内存地址。例如，考虑一个使用变量来表示不同重量的程序，假设这个变量被映射到计算机内存中的位置7。在二进制代码级别，处理该重量变量的指令必须使用显式的地址7。然而，在汇编层面上，可以允许使用类似`LOAD R3,weight`的命令来代替`LOAD R3,7`。在这两种情况下，命令都会实现相同的操作：“将Memory[7]的内容设置为R3”。同样，汇编语言允许使用诸如`goto loop`之类的命令代替`goto 250`，假设程序中的某个地方将符号`loop`指向地址250。

通常情况下，符号来源于汇编程序的两个方面：

- **变量（Variables）**：程序员可以使用符号变量名，翻译器会“自动”将它们分配到内存地址。注意，只要每个符号在程序翻译过程中解析到相同的地址，这些地址的实际值就无关紧要。
- **标签（Labels）**：程序员可以在程序中的不同位置用符号进行标记。例如，可以声明标签`loop`指向某段代码的开头。程序中的其他命令可以有条件或无条件地跳转到`loop`。

符号的引入使得汇编器需要比简单的文本处理程序更为复杂。尽管将公认的符号翻译为公认的二进制代码并不复杂，但将用户定义的变量名和符号标签映射到实际的内存地址并不简单。事实上，从硬件层次逐步上升到软件层次中，这种符号解析任务是我们遇到的第一个复杂的翻译挑战。以下示例将说明这一挑战以及常用的解决方法。

#### 符号解析

如图6.1所示，这是一个用某种自解释的低级语言编写的程序。该程序包含四个用户定义的符号：两个变量名（`i`和`sum`）以及两个标签（`loop`和`end`）。如何系统地将此程序转换为没有符号的代码？

首先，我们假设两条规则：翻译后的代码将从地址0开始存储在计算机的内存中，变量将从地址1024开始分配（这些规则取决于具体的目标硬件平台）。然后，建立一个**符号表（symbol table）**。对于代码中遇到的每个新符号`xxx`，在符号表中添加一行`(xxx, n)`，其中`n`是根据游戏规则分配的内存地址。构建符号表后，就可以使用它将程序转换为无符号的版本。

在假定的规则下，变量`i`和`sum`被分配到地址1024和1025。其他两个符号则是自解释的，唯一可能稍微难懂的是指令6：该指令通过让计算机进入无限循环来终止程序的执行。

---

### 6.2 Hack汇编到二进制的翻译规范

Hack汇编语言及其等效的二进制表示在第四章中进行了规定。为了方便参考，此处再次提供了该语言规范的简明和正式版本。这一规范可视为Hack汇编器必须实现的“契约”。

#### 6.2.1 语法约定和文件格式

- **文件名**：二进制机器代码和汇编代码的程序分别存储在以“.hack”和“.asm”扩展名结尾的文本文件中。例如，一个`Prog.asm`文件将被汇编器翻译为`Prog.hack`文件。

- **二进制代码（.hack）文件**：一个二进制代码文件由多行文本组成。每行都是一组16位“0”和“1”ASCII字符，编码单条16位机器语言指令。文件中的所有行共同表示一个机器语言程序。加载到计算机的指令内存中时，文件的第`n`行表示的二进制代码存储在指令内存地址`n`处。

- **汇编语言（.asm）文件**：一个汇编语言文件由多行文本组成，每行表示一条指令或一个符号声明。
  - **指令**：可以是A-指令或C-指令。
  - **(Symbol)**：这是一个伪指令，用于将符号绑定到程序中下一条指令将要存储的内存位置。它被称为“伪指令”，因为它不会生成机器代码。

- **常量和符号**：常量必须是非负数，用十进制表示。用户定义的符号可以是任意的字母、数字、下划线（_）、点（.）、美元符号（$）和冒号（:）的组合，但不能以数字开头。

- **注释**：以双斜杠（//）开头的文本和行尾的内容被视为注释，汇编时会忽略。

- **空格**：空格字符和空行会被忽略。

- **大小写约定**：所有汇编助记符必须大写。其余的（用户定义的标签和变量名）对大小写敏感。习惯上，标签使用大写，而变量名使用小写。

---

### 6.3 Hack汇编器的实现

Hack汇编器读取名为`Prog.asm`的输入文件，包含Hack汇编程序，并生成名为`Prog.hack`的输出文件，包含翻译后的Hack机器代码。输入文件名作为命令行参数传递给汇编器：

```bash
prompt> Assembler Prog.asm
```

每条汇编指令的翻译是直接且一对一的。每条命令都单独翻译。特别是，汇编命令的每个助记符组件（字段）根据规范表6.2.2翻译成相应的比特代码，命令中的每个符号根据规范表6.2.3解析成其数值地址。

### 6.3.1 解析器模块 (Parser Module)

解析器的主要功能是将每条汇编命令分解为其底层组成部分（字段和符号）。该模块的API如下所示。

**Parser**：封装对输入代码的访问。读取汇编语言命令，解析它，并提供对命令组成部分（字段和符号）的便捷访问。此外，它会去除所有空白字符和注释。

| 函数       | 参数             | 返回值                      | 功能说明                                                                                                                                                                                                 |
|------------|------------------|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 构造函数/初始化器 | 输入文件/流          | —                           | 打开输入文件/流，并准备进行解析。                                                                                                                                                                        |
| hasMoreCommands | —               | 布尔值                     | 检查输入中是否还有更多命令。                                                                                                                                                                              |
| advance    | —                | —                           | 从输入中读取下一条命令并将其设为当前命令。仅在`hasMoreCommands()`为真时调用。最初没有当前命令。                                                                                                          |
| commandType | —               | A_COMMAND, C_COMMAND, L_COMMAND | 返回当前命令的类型：`A_COMMAND`表示`@Xxx`（Xxx可以是符号或十进制数），`C_COMMAND`表示`dest=comp;jump`，`L_COMMAND`（实际上是伪命令）表示`(Xxx)`（Xxx是一个符号）。 |
| symbol     | —                | 字符串                     | 返回当前命令`@Xxx`或`(Xxx)`的符号或十进制值。仅当`commandType()`为`A_COMMAND`或`L_COMMAND`时调用。                                                                                                      |
| dest       | —                | 字符串                     | 返回当前C-命令中的`dest`助记符（共8种可能）。仅当`commandType()`为`C_COMMAND`时调用。                                                                                                                    |
| comp       | —                | 字符串                     | 返回当前C-命令中的`comp`助记符（共28种可能）。仅当`commandType()`为`C_COMMAND`时调用。                                                                                                                  |
| jump       | —                | 字符串                     | 返回当前C-命令中的`jump`助记符（共8种可能）。仅当`commandType()`为`C_COMMAND`时调用。                                                                                                                   |

### 6.3.2 代码模块 (Code Module)

**Code**：将Hack汇编语言助记符翻译成二进制代码。

| 函数         | 参数          | 返回值       | 功能说明                             |
|--------------|---------------|--------------|--------------------------------------|
| dest         | 助记符（字符串） | 3位           | 返回`dest`助记符的二进制代码。       |
| comp         | 助记符（字符串） | 7位           | 返回`comp`助记符的二进制代码。       |
| jump         | 助记符（字符串） | 3位           | 返回`jump`助记符的二进制代码。       |

### 6.3.3 无符号的汇编器

建议将汇编器分为两个阶段实现。第一阶段编写一个不支持符号的汇编器，可使用上面描述的`Parser`和`Code`模块。在第二阶段，扩展汇编器以支持符号处理。

第一阶段的合同要求输入的`Prog.asm`程序不包含符号。这意味着(a)所有`@Xxx`形式的地址命令中的Xxx为十进制数而非符号，且(b)输入文件不包含标签命令，即没有`(Xxx)`形式的命令。

整体的无符号汇编器可以如下实现。首先，程序打开一个名为`Prog.hack`的输出文件。接着，程序遍历`Prog.asm`文件中的每一行（即汇编指令）。对于每条C-指令，程序将指令字段的翻译二进制代码连接成一个16位字，并将该字写入`Prog.hack`文件。对于类型为`@Xxx`的A-指令，程序将解析器返回的十进制常量翻译成二进制表示，并将生成的16位字写入`Prog.hack`文件。

### 6.3.4 符号表模块 (SymbolTable Module)

由于Hack指令可能包含符号，因此必须在翻译过程中将这些符号解析为实际地址。汇编器使用一个符号表来完成此任务，以建立并维护符号与其含义（在Hack的情况下，是RAM和ROM地址）之间的对应关系。哈希表是一种适合表示这种关系的经典数据结构。在大多数编程语言中，标准库中通常已经提供了这种数据结构，因此无需从头开发。我们建议如下API：

**SymbolTable**：在符号标签和数值地址之间保持对应关系。

| 函数       | 参数           | 返回值       | 功能说明                                            |
|------------|----------------|--------------|-----------------------------------------------------|
| 构造函数     | —              | —            | 创建一个新的空符号表。                               |
| addEntry   | 符号（字符串）、地址（整数） | —            | 将符号和地址对（symbol, address）添加到符号表中。     |
| contains   | 符号（字符串）    | 布尔值       | 符号表中是否包含给定的符号。                          |
| getAddress | 符号（字符串）    | 整数         | 返回与符号相关联的地址。                             |

### 6.3.5 支持符号的汇编器

汇编程序允许在定义符号之前使用符号标签（即`goto`命令的目标）。这种约定简化了汇编程序员的工作，但也增加了汇编器开发者的复杂度。一个常见的解决方案是编写一个**两遍汇编器**，它从头到尾读取代码两次。在第一遍中，汇编器构建符号表，并不生成代码。在第二遍中，程序中的所有标签符号已绑定到内存位置并记录在符号表中，因此汇编器可以用对应的数值地址替换每个符号，并生成最终的二进制代码。

Hack语言中有三种符号类型：**预定义符号（predefined symbols）**、**标签（labels）** 和 **变量（variables）**。符号表应包含并处理所有这些符号，具体如下：

- **初始化**：根据6.2.3节的规定，使用所有预定义符号及其预分配的RAM地址初始化符号表。
- **第一遍**：逐行读取整个汇编程序，构建符号表，但不生成任何代码。在遍历程序行时，保持一个递增的ROM地址计数，用于记录当前指令最终加载到的内存位置。该计数从0开始，每遇到C指令或A指令时递增1，但遇到标签伪命令或注释时不变。每遇到一个伪命令`(Xxx)`，就在符号表中添加一个新条目，将Xxx与程序中下一条命令的ROM地址关联。此遍结束时，所有程序中的标签和它们的ROM地址都已进入符号表。变量将在第二遍处理中处理。
- **第二遍**：再次遍历整个程序，并逐行解析。每当遇到一个符号A指令（即`@Xxx`，Xxx是一个符号而非数字）时，在符号表中查找Xxx。如果在表中找到该符号，则用其数值含义替换，并完成命令的翻译。如果未找到该符号，则将其视为新变量。为此，向符号表中添加对`(Xxx, n)`，其中`n`是下一个可用的RAM地址，然后完成命令的翻译。分配的RAM地址为连续的数字，从地址16开始（即在预定义符号的地址之后）。

以上步骤完成了汇编器的实现。

---

### 6.4 展望

与大多数汇编器一样，Hack汇编器是一个相对简单的程序，主要处理文本处理。显然，对于更复杂的机器语言，汇编器的复杂性会更高。此外，一些汇编器具有Hack所没有的更复杂的符号处理功能。例如，汇编器可能允许程序员显式地将符号与特定的数据地址关联，对符号执行“常量运算”（如`table+5`表示符号`table`指向地址之后的第5个内存位置），等等。此外，许多汇编器能够处理宏命令。宏命令是具有名称的一组机器指令。例如，我们的汇编器可以扩展以翻译商定的宏命令，如`D=M[xxx]`，并将其转换为两条指令：`@xxx`和`D=M`（其中xxx为地址）。显然，这类宏命令可以大大简化常用操作的编程，且转换成本低。

需要注意的是

，独立的汇编器在实际中很少使用。首先，汇编程序很少由人类编写，而多由编译器生成。编译器作为自动化工具，不需要生成符号命令，因为直接生成二进制机器代码可能更方便。另一方面，许多高级语言编译器允许程序员在高级程序中嵌入汇编语言代码片段。这种功能在C语言编译器中非常普遍，使程序员可以直接控制底层硬件，以优化程序。

### 6.5 项目

**目标**：开发一个汇编器，将用Hack汇编语言编写的程序翻译为Hack硬件平台可理解的二进制代码。汇编器必须实现6.2节描述的翻译规范。

**资源**：完成此项目所需的唯一工具是实现汇编器的编程语言。书中提供的汇编器和CPU模拟器可以作为参考工具，让你在构建自己的汇编器之前，先尝试使用一个工作中的汇编器。此外，提供的汇编器提供逐行翻译的图形界面，并允许将输出与自己的汇编器生成的结果进行对比。

**合同**：当有效的Hack汇编语言程序`Prog.asm`文件加载到汇编器中时，它应翻译为正确的Hack二进制代码并存储在`Prog.hack`文件中。汇编器生成的输出必须与书中提供的汇编器生成的输出完全一致。

**构建计划**：建议将汇编器分为两个阶段构建。首先编写一个无符号的汇编器，即只能翻译不含符号的程序的汇编器。然后，扩展汇编器以支持符号处理。

**测试程序**：提供的测试程序帮助按增量测试汇编器，包括不带符号和带符号的版本。
